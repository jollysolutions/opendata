/*
 * Copyright 2014 Peter T Mount.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.trainwatch.analysis.performance;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.LongSummaryStatistics;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.json.Json;
import javax.json.JsonObjectBuilder;
import javax.json.JsonStructure;
import uk.trainwatch.io.AbstractPathMapper;
import uk.trainwatch.nrod.location.Stanox;
import uk.trainwatch.nrod.trust.model.TrainMovement;
import uk.trainwatch.util.TimeUtils;

/**
 * Analyses the performance of trains arriving, departing or passing a stanox
 * <p>
 * @author Peter T Mount
 */
public abstract class BaseDelayAnalyzer
        implements Consumer<TrainMovement>
{

    protected final Logger LOG;

    /**
     * The reportID generated by this analyzer
     */
    private final String reportId;

    private final Consumer<? super JsonStructure> recordingConsumer;
    private final Consumer<? super JsonStructure> realTimeConsumer;

    private LocalDateTime today;

    /**
     *
     * @param recordingConsumer Consumer that will receive the generated reports
     * @param realTimeConsumer  optional consumer to receive realtime updates per stanox
     */
    public BaseDelayAnalyzer( String reportId, Consumer<? super JsonStructure> recordingConsumer,
                              Consumer<? super JsonStructure> realTimeConsumer )
    {
        this.reportId = Objects.requireNonNull( reportId );
        this.recordingConsumer = Objects.requireNonNull( recordingConsumer, "Recording consumer is required" );
        this.realTimeConsumer = realTimeConsumer;

        LOG = Logger.getLogger( getClass().
                getName() );
    }

    protected final LocalDateTime getToday()
    {
        return today;
    }

    protected final String getReportId()
    {
        return reportId;
    }

    protected final Consumer<? super JsonStructure> getRecordingConsumer()
    {
        return recordingConsumer;
    }

    @Override
    public final void accept( TrainMovement mvt )
    {
        checkForPublishing();

        // Filter out stanox 0 as it doesn't exist.
        // Also filter out any movement that is before the current hour, we'll treat that as lost data
        // note: 300 seconds is to allow a 5 minute buffer if we are lagging when the hour changes
        final long stanox = Stanox.stanox( mvt.getReporting_stanox() + 300000L );
        if( stanox < 1 || TimeUtils.getLocalDateTime( mvt.getActual_timestamp() ).
                isBefore( today ) )
        {
            return;
        }

        final LongSummaryStatistics stat = getStatistic( mvt );

        stat.accept( mvt.getDelay() );

        notifyRealtime( mvt, stat );
    }

    /**
     * Return the Statistic appropriate for this movement
     * <p>
     * @param mvt <p>
     * @return
     */
    protected abstract LongSummaryStatistics getStatistic( TrainMovement mvt );

    /**
     * Ensures we record data to disk every minute but clear down the stats at the start of the hour as each file is for
     * each hour of the day
     * <p>
     * @param timestamp
     */
    private synchronized void checkForPublishing()
    {
        if( today == null )
        {
            // Start with the first record so do nothing
            today = LocalDateTime.now().
                    truncatedTo( ChronoUnit.MINUTES );
            LOG.log( Level.INFO, () -> "Starting report for " + today.truncatedTo( ChronoUnit.HOURS ) );

            return;
        }

        LocalDateTime date = AbstractPathMapper.getLocalDateTime().
                truncatedTo( ChronoUnit.MINUTES );

        if( !date.equals( today ) )
        {
            recordData();

            LocalDateTime hour1 = date.truncatedTo( ChronoUnit.HOURS );
            LocalDateTime hour2 = today.truncatedTo( ChronoUnit.HOURS );
            if( !hour1.equals( hour2 ) )
            {
                // New hour so clear down the statistics
                LOG.log( Level.INFO, () -> "Resetting for new hour " + hour2 );

                clearData();
            }

            // Update so the next run will match so won't run
            today = date;
        }
    }

    private void notifyRealtime( TrainMovement mvt, LongSummaryStatistics v )
    {
        if( realTimeConsumer != null )
        {
            JsonObjectBuilder b = Json.createObjectBuilder();
            addData( b, mvt, v );
            b.add( "toc", mvt.getToc_id() ).
                    add( "stanox", mvt.getReporting_stanox() ).
                    add( "count", v.getCount() ).
                    add( "minDelay", v.getMin() ).
                    add( "maxDelay", v.getMax() ).
                    add( "average", v.getAverage() ).
                    add( "sum", v.getSum() );

            realTimeConsumer.accept( Json.createObjectBuilder().
                    add( reportId, b ).
                    build() );
        }
    }

    /**
     * Add analyzer specific data to the statistics record. Once this returns we will add the statistic value to it
     * <p>
     * @param b
     */
    protected void addData( JsonObjectBuilder b, TrainMovement mvt, LongSummaryStatistics v )
    {
    }

    /**
     * Record the current data
     */
    protected abstract void recordData();

    protected abstract void clearData();
}
