/*
 * Copyright 2014 Peter T Mount.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.trainwatch.analysis.performance;

import java.time.LocalDateTime;
import java.util.LongSummaryStatistics;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.logging.Level;
import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;
import javax.json.JsonStructure;
import uk.trainwatch.io.report.ReportBuilder;
import uk.trainwatch.nrod.trust.model.TrainMovement;

/**
 * Analyses the performance of trains arriving, departing or passing a stanox
 * <p>
 * @author Peter T Mount
 */
public class TocStanoxAllClassDelayAnalyzer
        extends BaseDelayAnalyzer
{

    /**
     * The reportID generated by this analyzer
     */
    public static final String REPORT_ID = "TocStanoxAllClassPerformance";

    private final Map<Integer, Map<Long, LongSummaryStatistics>> stats = new ConcurrentHashMap<>();

    /**
     *
     * @param recordingConsumer Consumer that will receive the generated reports
     * @param realTimeConsumer  optional consumer to receive realtime updates per stanox
     */
    public TocStanoxAllClassDelayAnalyzer( Consumer<? super JsonStructure> recordingConsumer,
                                           Consumer<? super JsonStructure> realTimeConsumer )
    {
        super( REPORT_ID, recordingConsumer, realTimeConsumer );
    }

    @Override
    protected LongSummaryStatistics getStatistic( TrainMovement mvt )
    {
        return stats.computeIfAbsent( mvt.getToc_id(), toc -> new ConcurrentHashMap<>() ).
                computeIfAbsent( mvt.getReporting_stanox(), stanox -> new LongSummaryStatistics() );
    }

    @Override
    protected void clearData()
    {
        stats.clear();
    }

    @Override
    protected void addData( JsonObjectBuilder b, TrainMovement mvt, LongSummaryStatistics v )
    {
    }

    @Override
    protected void recordData()
    {
        stats.forEach( (toc, stanoxes) ->
        {
            if( !stanoxes.isEmpty() )
            {
                LOG.log( Level.FINE, () -> "Generating report for toc " + toc );

                JsonArrayBuilder ab = Json.createArrayBuilder();
                stanoxes.forEach( (s, v) -> ab.add( Json.createObjectBuilder().
                        add( "stanox", s ).
                        add( "count", v.getCount() ).
                        add( "minDelay", v.getMin() ).
                        add( "maxDelay", v.getMax() ).
                        add( "average", v.getAverage() ).
                        add( "sum", v.getSum() ) )
                );

                LocalDateTime today = getToday();

                ReportBuilder b = new ReportBuilder().
                        setReportId( REPORT_ID ).
                        setTitle( "Stanox performance by TOC " + toc ).
                        setDescription( "This report contains the analysed delays for all train classes at each stanox" ).
                        setRecordPath( "performance/stanox/%d/%d/%d/%d/%d",
                                       today.getYear(),
                                       today.getMonth().
                                       getValue(),
                                       today.getDayOfMonth(),
                                       today.getHour(),
                                       toc ).
                        add( "toc", toc ).
                        add( "stanoxes", ab );

                getRecordingConsumer().
                        accept( b.build() );
            }
        } );
    }

}
