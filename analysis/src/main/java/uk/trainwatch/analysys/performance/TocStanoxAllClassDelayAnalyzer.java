/*
 * Copyright 2014 Peter T Mount.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.trainwatch.analysys.performance;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.LongSummaryStatistics;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonStructure;
import uk.trainwatch.io.AbstractPathMapper;
import uk.trainwatch.io.report.ReportBuilder;
import uk.trainwatch.nrod.location.Stanox;
import uk.trainwatch.nrod.trust.model.TrainMovement;
import uk.trainwatch.util.TimeUtils;

/**
 * Analyses the performance of trains arriving, departing or passing a stanox
 * <p>
 * @author Peter T Mount
 */
public class TocStanoxAllClassDelayAnalyzer
        implements Consumer<TrainMovement>
{

    private static final Logger LOG = Logger.getLogger( TocStanoxAllClassDelayAnalyzer.class.getName() );

    /**
     * The reportID generated by this analyzer
     */
    public static final String REPORT_ID = "TocStanoxAllClassPerformance";

    private final Consumer<? super JsonStructure> recordingConsumer;
    private final Consumer<? super JsonStructure> realTimeConsumer;
    private final Map<Integer, Map<Long, LongSummaryStatistics>> stats = new ConcurrentHashMap<>();

    private final Map<Integer, Integer> counters = new ConcurrentHashMap();
    private LocalDateTime today;

    /**
     *
     * @param recordingConsumer Consumer that will receive the generated reports
     * @param realTimeConsumer  optional consumer to receive realtime updates per stanox
     */
    public TocStanoxAllClassDelayAnalyzer( Consumer<? super JsonStructure> recordingConsumer,
                                           Consumer<? super JsonStructure> realTimeConsumer )
    {
        this.recordingConsumer = Objects.requireNonNull( recordingConsumer, "Recording consumer is required" );
        this.realTimeConsumer = realTimeConsumer;
    }

    @Override
    public void accept( TrainMovement mvt )
    {
        checkForPublishing();

        // Filter out stanox 0 as it doesn't exist.
        // Also filter out any movement that is before the current hour, we'll treat that as lost data
        // note: 300 seconds is to allow a 5 minute buffer if we are lagging when the hour changes
        final long stanox = Stanox.stanox( mvt.getReporting_stanox() + 300000L );
        if( stanox < 1 || TimeUtils.getLocalDateTime( mvt.getActual_timestamp() ).
                isBefore( today ) )
        {
            return;
        }

        final int toc = mvt.getToc_id();

        final LongSummaryStatistics stat = stats.computeIfAbsent( toc, ConcurrentHashMap::new ).
                computeIfAbsent( stanox, id -> new LongSummaryStatistics() );

        stat.accept( mvt.getDelay() );

        notifyRealtime( toc, stanox, stat );
    }

    /**
     * Ensures we record data to disk every minute but clear down the stats at the start of the hour as each file is for
     * each hour of the day
     * <p>
     * @param timestamp
     */
    private synchronized void checkForPublishing()
    {
        if( today == null )
        {
            // Start with the first record so do nothing
            today = LocalDateTime.now().
                    truncatedTo( ChronoUnit.MINUTES );
            LOG.log( Level.INFO, () -> "Starting report for " + today.truncatedTo( ChronoUnit.HOURS ) );

            return;
        }

        LocalDateTime date = AbstractPathMapper.getLocalDateTime().
                truncatedTo( ChronoUnit.MINUTES );

        if( !date.equals( today ) )
        {
            stats.keySet().
                    forEach( this::recordData );

            LocalDateTime hour1 = date.truncatedTo( ChronoUnit.HOURS );
            LocalDateTime hour2 = today.truncatedTo( ChronoUnit.HOURS );
            if( !hour1.equals( hour2 ) )
            {
                // New hour so clear down the statistics
                LOG.log( Level.INFO, () -> "Resetting for new hour " + hour2 );

                stats.clear();
                counters.clear();
            }

            // Update so the next run will match so won't run
            today = date;
        }
    }

    private void notifyRealtime( int toc, long stanox, LongSummaryStatistics v )
    {
        if( realTimeConsumer != null )
        {
            realTimeConsumer.accept( Json.createObjectBuilder().
                    add( REPORT_ID, Json.createObjectBuilder().
                         add( "toc", toc ).
                         add( "stanox", stanox ).
                         add( "count", v.getCount() ).
                         add( "minDelay", v.getMin() ).
                         add( "maxDelay", v.getMax() ).
                         add( "average", v.getAverage() ).
                         add( "sum", v.getSum() )
                    ).
                    build() );
        }
    }

    /**
     * Record a single TOC to disk
     * <p>
     * @param toc toc id
     */
    private synchronized void recordData( int toc )
    {
        Map<Long, LongSummaryStatistics> stanoxes = stats.get( toc );
        if( stanoxes != null && !stanoxes.isEmpty() )
        {
            LOG.log( Level.INFO, () -> "Generating report for toc " + toc );

            JsonArrayBuilder ab = Json.createArrayBuilder();
            stanoxes.forEach( (s, v) -> ab.add( Json.createObjectBuilder().
                    add( "stanox", s ).
                    add( "count", v.getCount() ).
                    add( "minDelay", v.getMin() ).
                    add( "maxDelay", v.getMax() ).
                    add( "average", v.getAverage() ).
                    add( "sum", v.getSum() ) )
            );

            ReportBuilder b = new ReportBuilder().
                    setReportId( REPORT_ID ).
                    setTitle( "Stanox performance by TOC " + toc ).
                    setDescription( "This report contains the analysed delays for all train classes at each stanox" ).
                    setRecordPath( "performance/stanox/%d/%d/%d/%d/%d",
                                   today.getYear(),
                                   today.getMonth().
                                   getValue(),
                                   today.getDayOfMonth(),
                                   today.getHour(),
                                   toc ).
                    add( "toc", toc ).
                    add( "stanoxes", ab );

            recordingConsumer.accept( b.build() );
        }
    }

}
